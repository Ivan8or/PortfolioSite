<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Ivan's Projects</title>
    <link rel="icon" href="assets/img/favicon.svg">
    <link rel="stylesheet" type="text/css" href="assets/css/variables.css">
    <link rel="stylesheet" type="text/css" href="assets/css/navbar.css">
    <link rel="stylesheet" type="text/css" href="assets/css/projects.css">
</head>

<body>
    <header>
        <nav class="navbar">
            <li><a draggable="false" aria-label="Link to Home Page" href="/">
                Home</a></li>
            <li><a draggable="false" aria-label="Link to Projects" href="/projects.html">
                Projects</a></li>
            <li><a target="_blank" rel="noopener noreferrer" draggable="false" aria-label="Link to Github page" href="https://github.com/Ivan8or">
                Github</a></li>
            <li><a target="_blank" rel="noopener noreferrer" draggable="false" aria-label="Link to LinkedIn page" href="https://www.linkedin.com/in/ivan8or">
                LinkedIn</a></li>
            <li><a draggable="false" aria-label="Link to Resume" href="/resume.html">
                Resume</a></li>
            <li><a draggable="false" aria-label="Toggle Dark Mode" href="/">
                Dark Mode</a></li>
        </nav>
        <hr>
    </header>

    <h1 class="title">My Projects</h1>

    <ul class="projects-list">
        <li>
            <h2>Linear Chess (WIP)</h2>
            <h3>A nonstandard autochess genre game... with real chess!</h3>
            <a target="_blank" rel="noopener noreferrer" href="https://github.com/Ivan8or/LinearChess">
                Linear Chess Github Page</a>
            <h4>Introduction:</h4>
            <p>
                I was tutoring someone struggling with their CS classes over covid, and 
                one of their assignments was related to building a chess AI. 
                The assignment itself was straightforward: the AI would use the minimax
                algorithm to determine its moves, and all the student needed to do was
                implement several viable evaluation functions and compare them.
                The following few hours were some of the most interesting of my entire
                time working with any school assignment: throwing together a function 
                that calculated simple heuristics resulted in an AI that behaved exactly 
                as you expected it to. A single edit resulted in vastly different 
                behavior, with the possibility to make meaningful changes in seconds.
                This experience has stuck in the back of my mind for years, and I have
                recently finally gotten around to trying my hand at implementing
                a multiplayer game inspired by this satisfying responsiveness.
                <br>
                P.S. This project is still a work in progress, but I'm taking steps every
                day to reach my goal of an MVP that me and my friends online can play!
            </p>
            <h4>Design Considerations:</h4>
            <p>
                The bulk of the backend logic for this game is developed in Java, as 
                that is both the language I am the most comfortable with for large 
                projects, as well as being a solid middle ground between being 
                relatively performant while still allowing for a smooth development
                experience thanks to it having automatic memory management, 
                static typing, and support for the OOP paradigm. 
                <br>
                For the frontend UI, I chose React.js: I'm not overly concerned with
                client-side rendering being a performance issue for this kind of app,
                and React has a lot of community support (which goes a long way for a
                novice front-end developer like myself).
                <br>
                I have not commited to any particular database for this project yet. 
                but I am leaning towards choosing a relational database like MySQL
                or Postgres for their high performance with just a single instance. 
            </p>
        </li>
        <li>
            <h2>RadioScanner</h2>
            <h3>An encrypted, event-driven key/value messaging system</h3>
            <a target="_blank" rel="noopener noreferrer" href="https://github.com/Ivan8or/RadioScanner">
                Radio Scanner Github Page</a>
            <h4>Introduction:</h4>
            <p>
                When I was developing my dockerized university minecraft network,
                I found the need for my server instances to communicate with each
                other as well as with my bungeecord proxy. While the minecraft Bukkit
                API does have some support for this type of communication via plugin 
                messaging, their solution is not free of shortcomings. Most relevant
                to my situation is that their messaging will not work for a server that
                has 0 players online - which is unacceptable for my usecase where I
                will often want to communicate with a server that just launched or 
                that is about to be shut down. There are some excellent solutions
                that do what I need (namely Redis / RabbitMQ / most any other message 
                brokers), but I felt the need to stick to the spirit of DIY and implement
                my own messaging system. 
            </p>
            <h4>Design Considerations:</h4>
            <p>
                Most message broker solutions are a middleware, where the user needs to
                host a broker service which then manages communications sent through
                it. This allows messages to be queued if the recipient is unreachable, 
                as well as multicast messages efficiently. For my usecase, however, I 
                consider this extra functionality to be mostly unneeded and even a 
                detriment. I want a system which would be ready to use without any special
                setup, tailored to hobby spigot developers who simply want a reliable way
                for two servers to communicate. This is especially relevant when 
                considering that most minecraft managed hosting providers will not offer
                an easy way to deploy extra services (besides possibly an SQL database), 
                meaning that using a standard message broker would require server owners
                to break away from the streamlined process of running a managed server.
            </p>
        </li>

        <li>
            <h2>Project</h2>
            <h3>A very cool project probably</h3>
            <a target="_blank" rel="noopener noreferrer" href="/projects.html">
                Project Page</a>
            <h4>Introduction:</h4>
            <p>
                lorem ipsum
                lorem ipsum
                lorem ipsum
                lorem ipsum
                lorem ipsum
                lorem ipsum
                lorem ipsum
                lorem ipsum
                lorem ipsum
                lorem ipsum
                lorem ipsum
                lorem ipsum
                lorem ipsum
            </p>
        </li>
    </ul>
    
</body>